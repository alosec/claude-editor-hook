#!/usr/bin/env bash

# Debug logging
LOG="/tmp/claude-editor-hook.log"
echo "=== $(date) ===" >> "$LOG"
echo "Args: $@" >> "$LOG"
echo "TMUX: $TMUX" >> "$LOG"

# Store the file path
FILE="$1"

# Read pattern from config file (project-level or global)
PATTERN="${EDITOR_HOOK_PATTERN:-1}"  # Default to 1, or env var if set

# Check for project-level config first (takes precedence)
if [ -f ".claude-editor-hook.conf" ]; then
    source ".claude-editor-hook.conf"
    echo "Loaded config from: .claude-editor-hook.conf" >> "$LOG"
# Then check for global config
elif [ -f "$HOME/.claude-editor-hook.conf" ]; then
    source "$HOME/.claude-editor-hook.conf"
    echo "Loaded config from: ~/.claude-editor-hook.conf" >> "$LOG"
else
    echo "No config file found, using default or env var" >> "$LOG"
fi

echo "Using pattern: $PATTERN" >> "$LOG"

# Unset TMUX to allow nested sessions
unset TMUX

case "$PATTERN" in
    1)
        # Pattern 1: Simple emacs exec (like working nano pattern)
        echo "Pattern 1: Simple emacs exec" >> "$LOG"
        exec tmux new-session emacs -nw "$FILE"
        ;;

    2)
        # Pattern 2: display-popup + fzf (Interactive Picker)
        echo "Pattern 2: fzf popup menu" >> "$LOG"

        # Get the directory where this script lives (for finding lib/nested-tmux.conf)
        SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
        NESTED_CONF="$SCRIPT_DIR/../lib/nested-tmux.conf"

        # Create menu data
        MENU="Edit with Emacs:emacs -nw \"$FILE\"
Edit with Vi:vi \"$FILE\"
Edit with Nano:nano \"$FILE\"
Open Terminal:open-terminal
Detach:detach
Enhance (Interactive):claude-spawn-interactive
Enhance (Non-interactive):claude-enhance-auto"

        # Show popup with fzf and execute selection
        # Use -f flag to load nested config (backtick prefix + command palette binding)
        exec tmux -f "$NESTED_CONF" new-session bash -c "
            choice=\$(echo '$MENU' | fzf --height=10 --prompt='Command: ' --border --reverse)
            if [ -n \"\$choice\" ]; then
                cmd=\$(echo \"\$choice\" | cut -d: -f2)
                if [ \"\$cmd\" = \"open-terminal\" ]; then
                    # Open terminal - set PROMPT env var and drop into bash
                    export PROMPT='$FILE'
                    echo \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\"
                    echo \"Claude Editor Workspace\"
                    echo \"Type 'menu' to open command palette\"
                    echo \"Access prompt file: \\\$PROMPT\"
                    echo \"File: \$PROMPT\"
                    echo \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\"
                    echo \"\"
                    # Set up menu alias and launch bash with it available
                    # Source user's bashrc first, then add menu alias
                    exec bash --rcfile <(cat ~/.bashrc 2>/dev/null; echo 'alias menu=\"claude-editor-menu\"')
                elif [ \"\$cmd\" = \"detach\" ]; then
                    # Just exit cleanly - returns to Claude Code
                    exit 0
                elif [ \"\$cmd\" = \"claude-spawn-interactive\" ]; then
                    # Interactive enhancement - spawn new Claude window for investigation
                    # User can review and approve the enhanced prompt before returning

                    tmux new-window
                    tmux send-keys \"cndsp 'You are a prompt enhancement agent. The file $FILE contains a rough prompt from a user working with Claude Code. Your job: 1) Read the prompt, 2) Investigate the codebase to find relevant context (files, Beads issues, patterns, recent commits), 3) Rewrite the prompt with specific file paths, line numbers, and actionable context, 4) Save the enhanced prompt back to $FILE. Make it detailed enough that the original Claude instance can act on it immediately without further investigation.'\" Enter
                elif [ \"\$cmd\" = \"claude-enhance-auto\" ]; then
                    # Non-interactive enhancement - auto-replace *** markers *** with context
                    # Call claude -p with Haiku to read, investigate, and write back to file
                    claude -p --verbose --dangerously-skip-permissions --model haiku \"Read the file $FILE. It contains a prompt with sections marked *** text *** or <<< text >>> that need investigation. For each marked section, use Read, Grep, Bash tools to investigate and gather context (file paths, line numbers, Beads issues, patterns). Replace the marked sections with your findings. Write the enhanced prompt back to $FILE. Output only 'Done' when complete.\"

                    echo \"Press Enter to return to Claude Code...\"
                    read
                    # Return to Claude Code
                else
                    # Regular editor command - run without exec so tmux keybindings work
                    bash -c \"\$cmd\"
                fi
            fi
        "
        ;;

    3)
        # Pattern 3: Persistent Popup Session (Dismissable)
        echo "Pattern 3: Persistent popup session" >> "$LOG"
        SESSION="_editor_popup_$$"

        # Create persistent session if it doesn't exist
        if ! tmux has-session -t "$SESSION" 2>/dev/null; then
            tmux new-session -d -s "$SESSION" emacs -nw "$FILE"
            # Use -t flag to set option only for this session (not global)
            tmux set-option -t "$SESSION" status off
        fi

        # Attach in popup mode
        exec tmux attach -t "$SESSION"
        ;;

    4)
        # Pattern 4: Simple Default + Tmux Keybinding Menu
        echo "Pattern 4: Default + tmux keybinding menu" >> "$LOG"

        # Create temp tmux conf with menu binding
        TMUX_CONF=$(mktemp)
        cat > "$TMUX_CONF" <<EOF
# Source user's main tmux config first (for basic settings)
source-file ~/.tmux.conf

# Prefix is backtick (`) - doesn't conflict with text navigation
# Use set-option (not -g) for session-local changes
set-option prefix `
unbind-key C-b
bind-key ` send-prefix

# Bind Ctrl-A m to show menu
bind-key m display-menu -T "Switch Tool" -x C -y C \
    "Emacs" e "respawn-pane -k 'emacs -nw \"$FILE\"'" \
    "Vi" v "respawn-pane -k 'vi \"$FILE\"'" \
    "Nano" n "respawn-pane -k 'nano \"$FILE\"'" \
    "Batcat" b "respawn-pane -k 'batcat \"$FILE\"'"
EOF

        exec tmux -f "$TMUX_CONF" new-session emacs -nw "$FILE"
        ;;

    5)
        # Pattern 5: Split Pane Layout with Menu
        echo "Pattern 5: Split pane with menu" >> "$LOG"

        exec tmux new-session bash -c "
            # Show menu
            echo '━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━'
            echo 'Commands: (e)macs | (v)i | (n)ano | (b)atcat'
            echo '━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━'
            echo 'Press key to launch editor...'
            echo ''

            # Wait for keypress
            read -n1 choice

            # Launch editor
            case \$choice in
                e) exec emacs -nw '$FILE' ;;
                v) exec vi '$FILE' ;;
                n) exec nano '$FILE' ;;
                b) exec batcat '$FILE' ;;
                *) exec emacs -nw '$FILE' ;;
            esac
        "
        ;;

    6)
        # Pattern 6: Pre-launch Selection (External Menu)
        echo "Pattern 6: Pre-launch bash select menu" >> "$LOG"

        # Show menu using simple bash select
        PS3="Choose editor: "
        options=("Emacs" "Vi" "Nano" "Batcat")

        select opt in "${options[@]}"; do
            case $opt in
                "Emacs") EDITOR_CMD="emacs -nw \"$FILE\""; break ;;
                "Vi") EDITOR_CMD="vi \"$FILE\""; break ;;
                "Nano") EDITOR_CMD="nano \"$FILE\""; break ;;
                "Batcat") EDITOR_CMD="batcat \"$FILE\""; break ;;
                *) echo "Invalid option"; continue ;;
            esac
        done

        exec tmux new-session bash -c "$EDITOR_CMD"
        ;;

    7)
        # Pattern 7: run-shell with Command Execution
        echo "Pattern 7: run-shell with command execution" >> "$LOG"

        # Create wrapper scripts for each command
        TMPDIR=$(mktemp -d)

        cat > "$TMPDIR/editor-emacs.sh" <<EOF
#!/bin/bash
exec emacs -nw "$FILE"
EOF
        chmod +x "$TMPDIR/editor-emacs.sh"

        cat > "$TMPDIR/editor-vi.sh" <<EOF
#!/bin/bash
exec vi "$FILE"
EOF
        chmod +x "$TMPDIR/editor-vi.sh"

        cat > "$TMPDIR/editor-nano.sh" <<EOF
#!/bin/bash
exec nano "$FILE"
EOF
        chmod +x "$TMPDIR/editor-nano.sh"

        cat > "$TMPDIR/editor-batcat.sh" <<EOF
#!/bin/bash
exec batcat "$FILE"
EOF
        chmod +x "$TMPDIR/editor-batcat.sh"

        # Launch tmux with menu that uses run-shell
        exec tmux new-session bash -c "
            tmux display-menu -T 'Choose Editor' -x C -y C \
                'Emacs' e 'run-shell $TMPDIR/editor-emacs.sh' \
                'Vi' v 'run-shell $TMPDIR/editor-vi.sh' \
                'Nano' n 'run-shell $TMPDIR/editor-nano.sh' \
                'Batcat' b 'run-shell $TMPDIR/editor-batcat.sh'

            # Cleanup temp dir
            rm -rf '$TMPDIR'
        "
        ;;

    8)
        # Pattern 8: Hybrid - Menu then Respawn
        echo "Pattern 8: Hybrid menu then respawn" >> "$LOG"

        # Create temp config
        CONF=$(mktemp)
        cat > "$CONF" <<EOF
bind-key e respawn-pane -k "emacs -nw '$FILE'"
bind-key v respawn-pane -k "vi '$FILE'"
bind-key n respawn-pane -k "nano '$FILE'"
bind-key b respawn-pane -k "batcat '$FILE'"
EOF

        exec tmux -f "$CONF" new-session bash -c "
            tmux display-menu -T 'Choose Editor' -x C -y C \
                'Emacs' e 'send-keys e' \
                'Vi' v 'send-keys v' \
                'Nano' n 'send-keys n' \
                'Batcat' b 'send-keys b'

            # Hold session open
            sleep infinity
        "
        ;;

    9)
        # Pattern 9: Non-interactive prompt enhancement with claude -p + Haiku
        echo "Pattern 9: Non-interactive prompt enhancement" >> "$LOG"

        # Check if file has enhancement markers (*** or <<<>>>)
        if grep -qE '\*\*\*.*\*\*\*|<<<.*>>>' "$FILE"; then
            echo "Found enhancement markers, calling claude -p" >> "$LOG"

            # Create temp file for enhanced output
            ENHANCED=$(mktemp)

            # Pass file content to claude -p with enhancement instructions
            claude -p --model haiku "$(cat <<'PROMPT'
You are enhancing a prompt for Claude Code. The user has marked sections with *** or <<< >>> that need investigation and expansion.

Read the prompt below and look for sections marked with *** text *** or <<< text >>>.
For each marked section, use Read, Grep, Bash tools to investigate and gather context.
Replace marked sections with specific findings: file paths, line numbers, issue IDs, code patterns.

Output ONLY the enhanced prompt with markers replaced. No explanations, no meta-commentary.

Here is the prompt to enhance:
PROMPT
            )" "$(cat "$FILE")" > "$ENHANCED" 2>> "$LOG"

            if [ $? -eq 0 ] && [ -s "$ENHANCED" ]; then
                echo "Enhancement successful, updating file" >> "$LOG"
                mv "$ENHANCED" "$FILE"
            else
                echo "Enhancement failed, keeping original" >> "$LOG"
                rm -f "$ENHANCED"
            fi
        else
            echo "No enhancement markers found, skipping enhancement" >> "$LOG"
        fi

        # Don't open editor - return directly to Claude Code
        ;;

    *)
        # Default to Pattern 1 if invalid pattern specified
        echo "Invalid pattern '$PATTERN', defaulting to Pattern 1" >> "$LOG"
        exec tmux new-session emacs -nw "$FILE"
        ;;
esac
